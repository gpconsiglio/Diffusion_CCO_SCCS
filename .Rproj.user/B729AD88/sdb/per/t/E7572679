{
    "collab_server" : "",
    "contents" : "# Generating network in igraph\n\n######################################### SET-UP ##################################################################\n\nlibrary(sqldf)\nlibrary(igraph)\nlibrary(reshape2)\nlibrary(plyr)\n\n######################################### melt_cast.R #############################################################\n\n# Reads csv as data frame. Contains publications with authors, year, and method\nRawPubs <- read.csv(\"AllPubRaw.csv\", header=T, sep=\",\")\n\n# Edgelist from first author to other authors with year and method data\n# See 'eGO//melt_cast.R' for more documentation, or read up on the melt() function.\nPubMeltRaw <- melt(RawPubs, id.vars = c(\"Author1\", \"Year\", \"Method\"))\n\n# Many papers do not have 36 authors. Remove rows with no author data\n# Fill blank spaces with NA, then use na.omit\nPubMeltRaw[PubMeltRaw == \"\"] <- NA\nPubMelt <- na.omit(PubMeltRaw)\n\n######################################### concatenate.R ###########################################################\n\n# Divide data into two tables: first authors (a1) and 'other' authors (aO)----------------------------------------\n\nnodes_a1_raw <- sqldf(\"SELECT Author1 AS author, 'a1' AS type, Method AS method, Year AS year FROM PubMelt\")\nnodes_aO_raw <- sqldf(\"SELECT value AS author, 'aO' AS type, Method AS method, Year AS year FROM PubMelt\")\n\n# Authors who published in both methods are now either CCO,SSCO or SSCO,CCO\nnodes_a1_cm <- sqldf(\"SELECT author, type, GROUP_CONCAT(DISTINCT method) AS method, year AS Year\n                     FROM nodes_a1_raw\n                     GROUP BY author\")\n\nnodes_aO_cm <- sqldf(\"SELECT author, type, GROUP_CONCAT(DISTINCT method) AS method, year AS Year\n                     FROM nodes_aO_raw\n                     GROUP BY author\")\n\n# Create nodes list\nnodesall <- sqldf(\"SELECT author, type, method, year FROM nodes_a1_cm \n                  UNION SELECT author, type, method, year FROM nodes_aO_cm\")\n\n# concatenate authors who've published as both a1 & aO \nnodes <- sqldf(\"SELECT author, GROUP_CONCAT(type,'') AS type, method, min(year) AS year\n                FROM nodesall\n               GROUP BY author\")\n\n# Remove nodes beyond their initial entry (ie. first publication)\nnodes <- sqldf(\"SELECT author, type, method, min(year) AS year FROM nodes GROUP BY author\")\n\n\n# In the final table of nodes, all authors are listed with the year of their first publication in\n# the field, along with method(s) and type(s) of author position\n\n\n######################################## Name_to_ID.R #########################################################\n\n# Replace old data frame with new data frame that adds a column of numbered IDs\nnodes <- data.frame(i = 1:length(nodes$author), author = nodes$author, \n                    type = nodes$type, method = nodes$method, year = nodes$year)\n\n# Reseparate nodes (with numbered ID data) into two dataframes for a1 IDs and aO IDs\na1_id <- subset(nodes, type != 'aO', select = c(i, author, type, year))\naO_id <- subset(nodes, type != 'a1', select = c(i, author, type, year))\n\n# Rename columns (this will come in handy when we join the tables)\na1_id <- rename(a1_id, c(\"i\"=\"a1_id\"))\naO_id <- rename(aO_id, c(\"i\"=\"aO_id\"))\n\n# Let's join the tables!\nedges <- sqldf(\"SELECT PubMelt.Author1, a1_id.a1_id, PubMelt.value, PubMelt.year  \n                 FROM PubMelt INNER JOIN a1_id\n                 ON PubMelt.Author1 = a1_id.author\")\n\nedges <- sqldf(\"SELECT edges.Author1, edges.a1_id, edges.value, edges.year, aO_id.aO_id  \n                 FROM edges INNER JOIN aO_id\n                 ON edges.value = aO_id.author\")\n\n# final edges dataframe with only IDs and year\nedges <- data.frame(a1 = edges$a1_id, aO = edges$aO_id, year = edges$Year)\n\n# add edges ID to table\nedges$id <- 1:length('a1')\n\n############################################ NEW SCRIPT ##############################################################\n\n# generate an igraph object, using our edge list and vertice data\ng <- graph.data.frame(edges, directed = T, vertices = nodes)\n\n# Apply the Fruchterman-Reingold layout\nlayout_g <- layout.fruchterman.reingold(g)\n\n######################################################################################################################\n#                                   START RUNNING FUNCTION FROM HERE TO SAVE TIME                                    #\n######################################################################################################################\n\ncreate_graph_png <- function(max_date,i) {\n  \n  # Structure of function: subgraph.edges(graph, eids, delete.vertices = TRUE)\n  # Translation: make a subgraph of 'g'. Edgelist to use is entries in 'edges' which happened\n  # before the input date. (<= less than/equal to; which() returns T/F based on a logical condition)\n  # A subgraph gives part of a graph, but will only contain the specified vertices & edges.\n  gx <- subgraph.edges(g,\n                       edges[which(edges$year <= max_date),'i'], \n                       delete.vertices=F)\n\n  # Specify both the vertex fill and vertex frame colour. \"Black\" is a preset colour in igraph\n  V(gx)$color <- \"black\"\n  V(gx)$frame.color <- \"black\"\n  \n  # HSV is one of the ways to specify colour in programming. Often used for ease of controlling colour intensity\n  # Alpha value denotes transparency (This is consistent across many programming contexts)\n  col_a1 <- hsv(0,1,1,alpha=.5)\n  \n  # Select entries in 'nodes' which returns TRUE if their type is a1\n  # i.e. select 1st authors, and set their fill/frame colours to the colour defined in above col_a1\n  V(gx)[which(nodes$type == \"a1\")]$color <- col_a1\n  V(gx)[which(nodes$type == \"a1\")]$frame.color <- col_a1\n\n  # Repeat for aO node colours.\n  col_aO <- hsv(0.66,1,1,alpha=.5)\n  V(gx)[which(nodes$type == \"aO\")]$color <- col_aO\n  V(gx)[which(nodes$type == \"aO\")]$frame.color <- col_aO\n\n  # Repeat for those published as both author positions. | means OR\n  col_hybrid <- hsv(.7,1,1,alpha=.5)\n  V(gx)[which(nodes$type == \"a1aO\" | nodes$type == \"aOa1\")]$color <- col_hybrid\n  V(gx)[which(nodes$type == \"a1aO\" | nodes$type == \"aOa1\")]$frame.color <- col_hybrid\n\n  # the size of a node grows with the number of attached edges\n  V(gx)$size <- degree(gx)^(1/3)\n  \n  # new nodes emphasized by bright color and a changing size\n  newones <- \n  \n  # if node year - input year (i.e. max_date) is less/equal to 1, node will glow \n  V(gx)[which((max_date - nodes$year) <= 3)]$color <- newones\n  V(gx)[which((max_date - nodes$year) <= 3)]$frame.color <- newones\n  \n  # Similar logic. Make size 2.5 when node appears, after an age of 1 turn it to size 1.6\n  V(gx)[which((max_date - nodes$year) < 2)]$size <- 1.6\n  V(gx)[which((max_date - nodes$year) < 4)]$size <- 2.5\n  \n  # get's rid of the not yet to be displayed nodes\n  # [AL] this line is a little odd. technically, these nodes shouldn't have been drawn in anyway\n  # [AL] try taking these lines out and plotting again\n  notyet <- hsv(1,1,1,alpha=0)\n  \n  # This was in carpool code, but it seemed to cause a bug in this script?\n  # I don't see why this is needed either. Leaving it as a comment in case I'm overlooking something.\n  # V(gx)[which(degree(gx) < 1)]$frame.color=notyet \n  # V(gx)[which(degree(gx) < 1)]$color=notyet \n  # V(gx)[which(degree(gx) < 1)]$size=0\n  \n    bgcolor <- hsv(0.66,0.05,1)\n  \n  \n  # the textual annotations\n  plot_title <- paste(\"Co-authorship Network of CCO and SSCO Methods in Pharmacoepidemiology | \",max_date)\n  if(max_date <= 1995) {\n    plot_title <- paste(plot_title,\" - We can add a titles which change...\")\n  }\n  \n  if(max_date <= 2000) {\n    plot_title <- paste(plot_title,\" - ...overtime, to mark major events...\")\n  }\n  \n  if(max_date <= 2005) {\n    plot_title <- paste(plot_title,\" - ...or characterize certain time periods.\")\n  }\n  \n  if(max_date <= 2010) {\n    plot_title <- paste(plot_title,\" - cats\")\n  }\n  \n    # advertisement\n  sub_title <- \"First authors: red; Other authors: blue\"\n  \n  par(bg=bgcolor)\n  # let's create a PNG and plot the graph onto it\n  # 'sprintf()' runs the commands inside of it, but returns it in a string format\n  # (%03d, i): if i=1, you will see 001. if i=2, you will see 002. etc.\n  \n  ############### NTS: REMEMBER TO CHANGE THIS LOCATION EACH TIME U PRINT ##################\n  png(sprintf(\"C:\\\\Users\\\\Amy\\\\Dropbox\\\\d16summer\\\\eGO\\\\R_Git\\\\R_outputs\\\\testB\\\\testB%03d.png\", i),\n  width=5000, height=5000, bg=bgcolor, res=372)\n  ###########################################################################################\n  \n    plot(gx, margin=0, frame=F, main=plot_title, sub=sub_title, \n       vertex.label=NA, edge.color=rgb(.2,.2,.2), edge.arrow.mode=0, \n       layout=layout_g, edge.width=.8)\n  text(10,10, label=max_date)\n  dev.off() # shuts off current graphic printing device\n}\n\n\n# Let's print! Could take a while... =============================================================================\n\n# let's get it started!\n# First pub was in 1992, therefore start_date is 1991 because of the start_date+i argument\n# 2013 - 1991 = 22\n# Translation: loop the function we just wrote 22 times (start a 1995), to generate a new subgraph each year \none_year_prev <- 1991\nfor (i in c(1:22)) {\n  message(sprintf(\"printing year %d\", one_year_prev + i))\n  create_graph_png(one_year_prev + i, i)\n}\n\n\n# problems: \n\n\n",
    "created" : 1467333330015.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1267801327",
    "id" : "E7572679",
    "lastKnownWriteTime" : 1467334536,
    "last_content_update" : 1467334536919,
    "path" : "~/R_Git/graph.R",
    "project_path" : "graph.R",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}