one_year_prev <- 1991
for (i in c(1:25)) {
message(sprintf("printing year %d", one_year_prev + i))
create_graph_png(one_year_prev + i, i)
}
######################## test colours here:
plot(x=1:10, y=rep(7,10), pch=19, cex=3, col=rgb( .9, .0, .4, alpha=.4))
points(x=1:10, y=rep(6,10), pch=19, cex=3, col=rgb( .8, .4, .8, alpha=.4))
points(x=1:10, y=rep(5,10), pch=19, cex=3, col=rgb( .4, .3, 1, alpha=.4))
points(x=1:10, y=rep(4,10), pch=19, cex=3, col=rgb( .1, .6, 1 , alpha=.4))
create_graph_png <- function(max_date,i) {
# Structure of function: subgraph.edges(graph, eids, delete.vertices = TRUE)
# Translation: make a subgraph of 'g'. Edgelist to use is entries in 'edges' which happened
# before the input date. (<= less than/equal to; which() returns T/F based on a logical condition)
# A subgraph gives part of a graph, but will only contain the specified vertices & edges.
# 'i' in the subscript? doesn't feel right but ok, will keep it for now.
gx <- subgraph.edges(g,edges[which(edges$year <= max_date), 'id'],
delete.vertices=F)
# Specify both the vertex fill and vertex frame colour. "Black" is a preset colour in igraph
# V(gx) selects all nodes in the subgraph
# Probably not very necessary? (this is taken from the carpool code)
V(gx)$color <- "black"
V(gx)$frame.color <- "black"
# HSV is one of the ways to specify colour in programming. Often used for ease of controlling colour intensity
# Alpha value denotes transparency (This is consistent across many programming contexts)
# designates all a1 colours
col_a1 <- rgb( .9, .0, .4, alpha=.4)
# Select entries in 'nodes' which returns TRUE if their type is a1
# i.e. select 1st authors, and set their fill/frame colours to the colour defined in above col_a1
V(gx)[which(nodes$type == "a1")]$color <- col_a1
V(gx)[which(nodes$type == "a1")]$frame.color <- col_a1
# Repeat for aO
col_aO <- rgb( .1, .6, 1 , alpha=.4)
V(gx)[which(nodes$type == "aO")]$color <- col_aO
V(gx)[which(nodes$type == "aO")]$frame.color <- col_aO
# Repeat for those published as both author positions. | means OR
col_hybrid <- rgb( .4, .3, 1, alpha=.4)
V(gx)[which(nodes$type == "a1aO" | nodes$type == "aOa1")]$color <- col_hybrid
V(gx)[which(nodes$type == "a1aO" | nodes$type == "aOa1")]$frame.color <- col_hybrid
# the size of a node grows with the number of attached edges
V(gx)$size <- log(3*degree(gx))
##### FEATURE CURRENTLY VOIDED #################################################################
#
# if node is 3 years or less, colour glows green.
# logic statement: year of network (max_date) - year of the node is less/equal to 3
#newones <- hsv(.36,1,1,alpha=.5)
#V(gx)[which((max_date - nodes$year) <= 3)]$color <- newones
#V(gx)[which((max_date - nodes$year) <= 3)]$frame.color <- newones
#
# New nodes come in very big, then decreases, then "settles" at a "native size"
#V(gx)[which((max_date - nodes$year) <= 1)]$size <- 7
#V(gx)[which( ((max_date - nodes$year)>1) & ((max_date - nodes$year)<=3) )]$size <- 1.6
#
###############################################################################################
# Get's rid of the not yet to be displayed nodes
# So technically, if gx is being made corretly, this should be needed.
# For some reason, nodes from beyond 1992 is showing up in the 1992 graph, etc.
# This fixes the bug, but I'm still trying to figure out exactly why...
# alpha = 0 means completely transparent
notyet <- hsv(1,1,1,alpha=0)
V(gx)[which(degree(gx) < 1)]$frame.color=notyet
V(gx)[which(degree(gx) < 1)]$color=notyet
V(gx)[which(degree(gx) < 1)]$size=0
bgcolor <- hsv(0.66,0.05,1)
# the textual annotations
plot_title <- paste("Co-authorship Network of CCO and SSCO Methods in Pharmacoepidemiology | ")
if(max_date < 2013) {
plot_title <- paste(plot_title, max_date)
}
if(max_date >= 2013) {
plot_title <- paste(plot_title, "2013")
}
# Legend
sub_title <- "PINK = First authors || BLUE = Other authors || PURPLE: Publishd as both"
par(bg=bgcolor)
# let's create a PNG and plot the graph onto it
# 'sprintf()' runs the commands inside of it, but returns it in a string format
# (%03d, i): if i=1, you will see 001. if i=2, you will see 002. etc.
############### NTS: REMEMBER TO CHANGE THIS LOCATION EACH TIME U PRINT ##################
png(sprintf("C:\\Users\\Amy\\Documents\\R_Git\\R_outputs\\testI\\testI%02d.png", i),
width=5000, height=5000, bg=bgcolor, res=372)
###########################################################################################
plot(gx, margin=0, frame=F, main=plot_title, sub=sub_title,
vertex.label=NA, edge.color=rgb(.2,.2,.2), edge.arrow.mode=0,
layout=layout_g, edge.width=.8)
text(10,10, label=max_date)
dev.off() # shuts off current graphic printing device
}
# Let's print! Could take a while... =============================================================================
# let's get it started!
# First pub was in 1992, therefore start_date is 1991 because of the start_date+i argument
# 2013 - 1991 = 22
# Translation: loop the function we just wrote 22 times (start a 1995), to generate a new subgraph each year
one_year_prev <- 1991
for (i in c(1:25)) {
message(sprintf("printing year %d", one_year_prev + i))
create_graph_png(one_year_prev + i, i)
}
?par
library(sqldf)
library(igraph)
library(reshape2)
# Reads csv as data frame. Contains publications with authors, year, and method
# Table was saved as a comma-delimited .csv file, hence the sep="," argument.
RawPubs <- read.csv("AllPubRaw.csv", header=T, sep=",")
# What is the melt() function? DEMO ==================================================================================
# Melt df, with variable ID as authors 1-9
# we need to choose an identification variable, which must be a string
# sprint() prints a string, which id.vars needs
# %d, [number] tells the program to replace %d with the number after the comma
# This is why we need the au_n vector
# allows us to select authors from 1-9 without typing repeatedly
au_n = c(1:9)
PubMeltEx <- melt(RawPubs, id.vars = c(sprintf("Author%d", au_n)))
#################### CG data test ##############################
# Edgelist from first author to other authors with year and method data
PubMelt <- melt(RawPubs, id.vars = c("Author1", "Year", "Method"))
# Many papers do not have 36 authors. Remove rows with no author data
# Change all blanks to NA, a unique type recognized by R
PubMelt[PubMelt == ""] <- NA
# We can now use the na.omit function to omit all NA
PubMelt <- na.omit(PubMelt)
# StackOverflow solutions which should work but didn't...
# PubMelt <- PubMelt[-which(PubMeltRaw$variable == "")]  #error
# PubMelt <- PubMelt[,complete.cases(PubMeltBlanks)]  #error
# PubMelt <- PubMelt[!(PubMeltBlanks$variable == "")]  #error
View(RawPubs)
View(PubMeltRaw)
View(nodes)
rm(list=(ls))
rm(list=(ls))
?rm()
rm(list=(ls()))
rm(list=ls())
RawPubs <- read.csv("AllPubRaw.csv", header=T, sep=",")
View(RawPubs)
PubMeltRaw <- melt(RawPubs, id.vars = c("Author1", "Year", "Method"))
View(PubMeltRaw)
# Fill blank spaces with NA, then use na.omit
PubMeltRaw[PubMeltRaw == ""] <- NA
PubMelt <- na.omit(PubMeltRaw)
nodes_a1_raw <- sqldf("SELECT Author1 AS author, 'a1' AS type, Method AS method, Year AS year FROM PubMelt")
nodes_aO_raw <- sqldf("SELECT value AS author, 'aO' AS type, Method AS method, Year AS year FROM PubMelt")
View(nodes_a1_raw)
# this script documents the steps/logic reasoning behind generating the edgelist for network1.R
############## SET UP (ie. first part of network1.R script, to generate objects we need) ##########################
library(sqldf) # to quote SQL
library(igraph) # to generate network objects
library(reshape2) # to melt
library(plyr) # to rename
# Reads csv as data frame. Contains publications with authors, year, and method
RawPubs <- read.csv("AllPubRaw.csv", header=T, sep=",")
# Edgelist from first author to other authors with year and method data
# See 'eGO//melt_cast.R' for more documentation, or read up on the melt() function.
PubMelt <- melt(RawPubs, id.vars = c("Author1", "Year", "Method")) # Ignore warning message
# Many papers do not have 36 authors. Remove rows with no author data
# Fill blank spaces with NA, then use na.omit
PubMelt[PubMelt == ""] <- NA
PubMelt <- na.omit(PubMelt)
############################################ NEW SCRIPT ##########################################################
# Divide data into two tables: first authors (a1) and 'other' authors (aO)----------------------------------------
# I used SQL because the carpool sample code used SQL. While it's difficult and confusing learn two languages
# simulatenously, SQL produces more elegant and clean results with less code.
# More documentation on SQL synthax in eGO
# SELECT [name of original column] AS [name of new column]
# add a new column named 'type' and fill it with a1
nodes_a1_cm <- sqldf("SELECT author, type, GROUP_CONCAT(DISTINCT method) AS method, year AS Year
FROM nodes_a1_raw
GROUP BY author")
# Authors who published in both methods are now either CCO,SSCO or SSCO,CCO
# Repeat for aO:
nodes_aO_cm <- sqldf("SELECT author, type, GROUP_CONCAT(DISTINCT method) AS method, year AS Year
FROM nodes_aO_raw
GROUP BY author")
# this script documents the steps/logic reasoning behind generating the edgelist for network1.R
############## SET UP (ie. first part of network1.R script, to generate objects we need) ##########################
library(sqldf) # to quote SQL
library(igraph) # to generate network objects
library(reshape2) # to melt
library(plyr) # to rename
# Reads csv as data frame. Contains publications with authors, year, and method
RawPubs <- read.csv("AllPubRaw.csv", header=T, sep=",")
# Edgelist from first author to other authors with year and method data
# See 'eGO//melt_cast.R' for more documentation, or read up on the melt() function.
PubMelt <- melt(RawPubs, id.vars = c("Author1", "Year", "Method")) # Ignore warning message
# Many papers do not have 36 authors. Remove rows with no author data
# Fill blank spaces with NA, then use na.omit
PubMelt[PubMelt == ""] <- NA
PubMelt <- na.omit(PubMelt)
############################################ NEW SCRIPT ##########################################################
# Divide data into two tables: first authors (a1) and 'other' authors (aO)----------------------------------------
# I used SQL because the carpool sample code used SQL. While it's difficult and confusing learn two languages
# simulatenously, SQL produces more elegant and clean results with less code.
# More documentation on SQL synthax in eGO
# SELECT [name of original column] AS [name of new column]
# add a new column named 'type' and fill it with a1
nodes_a1_raw <- sqldf("SELECT Author1 AS author, 'a1' AS type, Method AS method, Year AS year FROM PubMelt")
nodes_aO_raw <- sqldf("SELECT value AS author, 'aO' AS type, Method AS method, Year AS year FROM PubMelt")
# What if an author used both CCO and SSCO? Later on, we'll be deleting all entries beyond the first
# year. Hence, we need to determine which authors have used both method early on.
# To do this, we'll concatenate values in the 'method' column
# (We don't need to rename 'author' or 'type' columns. In SQL, we don't need to add AS after the expression)
# group_concat() collapses data for the same individual repeated in different rows into the same row.
# THE CODE BELOW IS FAULTY, but run it for learning purposes:
nodes_a1_cm_error <- sqldf("SELECT author, type, GROUP_CONCAT(method) AS method, year AS Year
FROM nodes_a1_raw
GROUP BY author")
# However, notice that authors with >1 publications end up with a huge messy chain of methods
# Hence, add the DISTINCT argument to only concatendate different values (i.e. only collapse if both
# CCO and SSCO, not if only one)
nodes_a1_cm <- sqldf("SELECT author, type, GROUP_CONCAT(DISTINCT method) AS method, year AS Year
FROM nodes_a1_raw
GROUP BY author")
# Authors who published in both methods are now either CCO,SSCO or SSCO,CCO
# Repeat for aO:
nodes_aO_cm <- sqldf("SELECT author, type, GROUP_CONCAT(DISTINCT method) AS method, year AS Year
FROM nodes_aO_raw
GROUP BY author")
# at this point, authors who are both aO and a1 should be in both tables
# Create nodes list (i.e. all authors) -----------------------------------------------------------------
# "Union select" is SQL for "the union of set A and set B" (think about probability and set theory).
# We want a table of all nodes, and their type as an attribute. Thus, union select both tables.
# Currently, the author is re-listed every time they publish again. (e.g. see Andrews N)
nodesall <- sqldf("SELECT author, type, method, year FROM nodes_a1_cm
UNION SELECT author, type, method, year FROM nodes_aO_cm")
# Authors who've published as both a1 & aO ------------------------------------------------------------------
# Group because a person can be first author and a collab author.
# THIS CODE IS WRONG. Notice what happens if we don't specify min(year):
nodes <- sqldf("SELECT author, GROUP_CONCAT(type,'') AS type, method, year
FROM nodes
GROUP BY author")
# Alright, let's fix it up:
nodes <- sqldf("SELECT author, GROUP_CONCAT(type,'') AS type, method, min(year) AS year
FROM nodesall
GROUP BY author")
# Now that we've characterized all authors by type(s) and method(s), we can
# remove nodes beyond their initial entry (ie. first publication)
# GROUP BY allows us to collapse multiple entries. min(year) specifies which which year value to keep.
# for example, you can also do avg(year), etc.
# BELOW CODE IS NOT WHAT WE WHAT. Run it to learn about SQL synthax...
nodes <- sqldf("SELECT author, type, method, min(year) FROM nodes GROUP BY author")
# We want a clean column name. New version of line above, to rename in one step:
nodes <- sqldf("SELECT author, type, method, min(year) AS year FROM nodes GROUP BY author")
# In the final table of nodes, all authors are listed with the year of their first publication in
# the field, along with method and type of author (first author or other author)
# NB: those who've published as both author positions has type "a1aO" or "aOa1"
# this script documents the steps/logic reasoning behind generating the edgelist for network1.R
############## SET UP (ie. first part of network1.R script, to generate objects we need) ##########################
library(sqldf) # to quote SQL
library(igraph) # to generate network objects
library(reshape2) # to melt
library(plyr) # to rename
# Reads csv as data frame. Contains publications with authors, year, and method
RawPubs <- read.csv("AllPubRaw.csv", header=T, sep=",")
# Edgelist from first author to other authors with year and method data
# See 'eGO//melt_cast.R' for more documentation, or read up on the melt() function.
PubMelt <- melt(RawPubs, id.vars = c("Author1", "Year", "Method")) # Ignore warning message
# Many papers do not have 36 authors. Remove rows with no author data
# Fill blank spaces with NA, then use na.omit
PubMelt[PubMelt == ""] <- NA
PubMelt <- na.omit(PubMelt)
############################################ NEW SCRIPT ##########################################################
# Divide data into two tables: first authors (a1) and 'other' authors (aO)----------------------------------------
# I used SQL because the carpool sample code used SQL. While it's difficult and confusing learn two languages
# simulatenously, SQL produces more elegant and clean results with less code.
# More documentation on SQL synthax in eGO
# SELECT [name of original column] AS [name of new column]
# add a new column named 'type' and fill it with a1
nodes_a1_raw <- sqldf("SELECT Author1 AS author, 'a1' AS type, Method AS method, Year AS year FROM PubMelt")
nodes_aO_raw <- sqldf("SELECT value AS author, 'aO' AS type, Method AS method, Year AS year FROM PubMelt")
# What if an author used both CCO and SSCO? Later on, we'll be deleting all entries beyond the first
# year. Hence, we need to determine which authors have used both method early on.
# To do this, we'll concatenate values in the 'method' column
# (We don't need to rename 'author' or 'type' columns. In SQL, we don't need to add AS after the expression)
# group_concat() collapses data for the same individual repeated in different rows into the same row.
# THE CODE BELOW IS FAULTY, but run it for learning purposes:
nodes_a1_cm_error <- sqldf("SELECT author, type, GROUP_CONCAT(method) AS method, year AS Year
FROM nodes_a1_raw
GROUP BY author")
# However, notice that authors with >1 publications end up with a huge messy chain of methods
# Hence, add the DISTINCT argument to only concatendate different values (i.e. only collapse if both
# CCO and SSCO, not if only one)
nodes_a1_cm <- sqldf("SELECT author, type, GROUP_CONCAT(DISTINCT method) AS method, year AS Year
FROM nodes_a1_raw
GROUP BY author")
# Authors who published in both methods are now either CCO,SSCO or SSCO,CCO
# Repeat for aO:
nodes_aO_cm <- sqldf("SELECT author, type, GROUP_CONCAT(DISTINCT method) AS method, year AS Year
FROM nodes_aO_raw
GROUP BY author")
# at this point, authors who are both aO and a1 should be in both tables
# Create nodes list (i.e. all authors) -----------------------------------------------------------------
# "Union select" is SQL for "the union of set A and set B" (think about probability and set theory).
# We want a table of all nodes, and their type as an attribute. Thus, union select both tables.
# Currently, the author is re-listed every time they publish again. (e.g. see Andrews N)
nodesall <- sqldf("SELECT author, type, method, year FROM nodes_a1_cm
UNION SELECT author, type, method, year FROM nodes_aO_cm")
# Authors who've published as both a1 & aO ------------------------------------------------------------------
# Group because a person can be first author and a collab author.
# THIS CODE IS WRONG. Notice what happens if we don't specify min(year):
nodes <- sqldf("SELECT author, GROUP_CONCAT(type,'') AS type, method, year
FROM nodes
GROUP BY author")
# Alright, let's fix it up:
nodes <- sqldf("SELECT author, GROUP_CONCAT(type,'') AS type, method, min(year) AS year
FROM nodesall
GROUP BY author")
# Now that we've characterized all authors by type(s) and method(s), we can
# remove nodes beyond their initial entry (ie. first publication)
# GROUP BY allows us to collapse multiple entries. min(year) specifies which which year value to keep.
# for example, you can also do avg(year), etc.
# BELOW CODE IS NOT WHAT WE WHAT. Run it to learn about SQL synthax...
nodes <- sqldf("SELECT author, type, method, min(year) FROM nodes GROUP BY author")
# We want a clean column name. New version of line above, to rename in one step:
nodes <- sqldf("SELECT author, type, method, min(year) AS year FROM nodes GROUP BY author")
# In the final table of nodes, all authors are listed with the year of their first publication in
# the field, along with method and type of author (first author or other author)
# NB: those who've published as both author positions has type "a1aO" or "aOa1"
############## CODE WHICH DOESN'T WORK? ################################
# for learning purposes, let's try a few things with R syntax:
nodes['CCO'] # error: no column name specified
nodes$method['apples'] # N/A (b/c there are none with this method)
nodes$method['CCO'] # still doesn't work????
# this script documents the steps/logic reasoning behind generating the edgelist for network1.R
############## SET UP (ie. first part of network1.R script, to generate objects we need) ##########################
library(sqldf) # to quote SQL
library(igraph) # to generate network objects
library(reshape2) # to melt
library(plyr) # to rename
# Reads csv as data frame. Contains publications with authors, year, and method
RawPubs <- read.csv("AllPubRaw.csv", header=T, sep=",")
# Edgelist from first author to other authors with year and method data
# See 'eGO//melt_cast.R' for more documentation, or read up on the melt() function.
PubMelt <- melt(RawPubs, id.vars = c("Author1", "Year", "Method")) # Ignore warning message
# Many papers do not have 36 authors. Remove rows with no author data
# Fill blank spaces with NA, then use na.omit
PubMelt[PubMelt == ""] <- NA
PubMelt <- na.omit(PubMelt)
library(sqldf)
library(igraph)
library(reshape2)
library(plyr)
######################################### melt_cast.R #############################################################
# Reads csv as data frame. Contains publications with authors, year, and method
RawPubs <- read.csv("AllPubRaw.csv", header=T, sep=",")
# Generates preliminary edgelist from first author to other authors, with year and method data
PubMeltRaw <- melt(RawPubs, id.vars = c("Author1", "Year", "Method"))
# Many papers do not have 36 authors. Remove rows with no author data
# Fill blank spaces with NA, then use na.omit
PubMeltRaw[PubMeltRaw == ""] <- NA
PubMelt <- na.omit(PubMeltRaw)
######################################### concatenate.R ###########################################################
# Divide data into two tables: first authors (a1) and 'other' authors (aO)----------------------------------------
nodes_a1_raw <- sqldf("SELECT Author1 AS author, 'a1' AS type, Method AS method, Year AS year FROM PubMelt")
nodes_aO_raw <- sqldf("SELECT value AS author, 'aO' AS type, Method AS method, Year AS year FROM PubMelt")
# Authors who published in both methods are now either CCO,SSCO or SSCO,CCO
nodes_a1_cm <- sqldf("SELECT author, type, GROUP_CONCAT(DISTINCT method) AS method, year AS Year
FROM nodes_a1_raw
GROUP BY author")
nodes_aO_cm <- sqldf("SELECT author, type, GROUP_CONCAT(DISTINCT method) AS method, year AS Year
FROM nodes_aO_raw
GROUP BY author")
# Create nodes list
nodesall <- sqldf("SELECT author, type, method, year FROM nodes_a1_cm
UNION SELECT author, type, method, year FROM nodes_aO_cm")
# concatenate authors who've published as both a1 & aO
nodes <- sqldf("SELECT author, GROUP_CONCAT(type,'') AS type, method, min(year) AS year
FROM nodesall
GROUP BY author")
# Remove nodes beyond their initial entry (ie. first publication)
nodes <- sqldf("SELECT author, type, method, min(year) AS year FROM nodes GROUP BY author")
# In the final table of nodes, all authors are listed with the year of their first publication in
# the field, along with method(s) and type(s) of author position
######################################## Name_to_ID.R #########################################################
# Replace old data frame with new data frame that adds a column of numbered IDs
nodes <- data.frame(i = 1:length(nodes$author), author = nodes$author,
type = nodes$type, method = nodes$method, year = nodes$year)
# Reseparate nodes (with numbered ID data) into two dataframes for a1 IDs and aO IDs
a1_id <- subset(nodes, type != 'aO', select = c(i, author, type, year))
aO_id <- subset(nodes, type != 'a1', select = c(i, author, type, year))
# Rename columns (this will come in handy when we join the tables)
a1_id <- rename(a1_id, c("i"="a1_id"))
aO_id <- rename(aO_id, c("i"="aO_id"))
# Let's join the tables!
edges <- sqldf("SELECT PubMelt.Author1, a1_id.a1_id, PubMelt.value, PubMelt.year
FROM PubMelt INNER JOIN a1_id
ON PubMelt.Author1 = a1_id.author")
edges <- sqldf("SELECT edges.Author1, edges.a1_id, edges.value, edges.year, aO_id.aO_id
FROM edges INNER JOIN aO_id
ON edges.value = aO_id.author")
# final edges dataframe with only IDs and year
edges <- data.frame(a1 = edges$a1_id, aO = edges$aO_id, year = edges$Year)
# add edges ID to table
edges$id <- 1:length(edges$a1)
View(nodes)
View(PubMeltRaw)
View(PubMeltRaw)
View(RawPubs)
write.cs(PubMelt)
write.csv(PubMelt)
?write.csv()
View(nodes)
quality <- read.csv("qualityData", header=T, sep=",")
quality <- read.csv("qualityData.csv", header=T, sep=",")
View(quality)
quality <- read.csv("qualityData.csv", header=T, sep=",")
View(quality)
View(quality)
quality <- read.csv("qualityData.csv", header=T, sep=",")
View(quality)
View(quality)
?write.csv()
write.csv(quality2013[quality$year < 2013, ], "quality2012trial")
quality2013 <- read.csv("quality2013.csv", header=T, sep=",")
write.csv(quality2013[quality$year < 2013, ], "quality2012trial")
write.csv(quality2013[quality$year < 2013, ], "quality2012trial.csv")
for i in c(1:21) {
write.csv(quality2013[quality$year < (2013-i), ], sprintf("quality%d.csv", (2013-i))
}
for (i in c(1:21)) {
write.csv(quality2013[quality$year < (2013-i), ], sprintf("quality%d.csv", (2013-i))
}
for (i in c(1:21)) {
write.csv(quality2013[quality$year < (2013-i), ], sprintf("quality%d.csv", (2013-i)))
}
?data.frame
?printf()
?sprintf()
install.library(igraph)
install.packages(igraph)
install.packages("statnet")
View(quality2013)
# -------
for (i in c(1:21)) {
T <- quality2013[quality2013$year < (2013-i), ]
print(i)
print(2013-i)
print(T)
message("---------------------------------")
#write.csv(T, sprintf("quality%d.csv", (2013-i)))
}
for (i in c(1:3)) {
T <- quality2013[quality2013$year < (2013-i), ]
print(i)
print(2013-i)
print(T)
message("---------------------------------")
#write.csv(T, sprintf("quality%d.csv", (2013-i)))
}
# Create dataframe for the rest of the years
for (i in c(20:22)) {
temp <- quality2013[quality2013$year < (2013-i), ]
list <- (temp)
print(list)
message("---------------------------------")
#write.csv(T, sprintf("quality%d.csv", (2013-i))) # add back if we need to print tables
}
# Create dataframe for the rest of the years
for (i in c(18:21)) {
temp <- quality2013[quality2013$year < (2013-i), ]
list <- (temp)
print(list)
message("---------------------------------")
#write.csv(T, sprintf("quality%d.csv", (2013-i))) # add back if we need to print tables
}
# Create dataframe for the rest of the years
for (i in c(1:5)) {
temp <- quality2013[quality2013$year < (2013-i), ]
list <- (temp)
print(list)
message("---------------------------------")
#write.csv(T, sprintf("quality%d.csv", (2013-i))) # add back if we need to print tables
}
L <- list()
L[1] <- "hi"
L[3] <- "third"
quality <- list();
for (i in c(1:21)) {
tbl <- quality2013[quality2013$year < (2013-i), ]
list[i] <- tb1
}
print(quality)
quality <- list();
for (i in c(1:21)) {
tbl <- quality2013[quality2013$year < (2013-i), ]
list[i] <- tb1
}
print(quality)
for (i in c(1:21)) {
tbl <- quality2013[quality2013$year < (2013-i), ]
}
list[i] <- tb1
for (i in c(1:21)) {
tbl <- quality2013[quality2013$year < (2013-i), ]
}
quality <- list();
for (i in c(1:21)) {
tbl <- quality2013[quality2013$year < (2013-i), ]
quality[i] <- tb1
}
quality <- list();
for (i in c(1:21)) {
tbl <- quality2013[quality2013$year < (2013-i), ]
}
quality[i] <- tb1
quality <- list();
for (i in c(1:21)) {
tbl <- quality2013[quality2013$year < (2013-i), ]
quality[i] <- tbl
}
warning()
print(quality)
